# qt-bison-flex

This is a sample project demonstrating the integration of a Flex/Bison parser into a Qt GUI application. Since code demonstration is the main goal of this project, no binaries are included. The project can be opened and compiled with [Qt Creator][creator]. A detailed description of the code is provided [below](#about).

## Setup

Since [kits][kits], compiler paths etc. are almost certainly different between systems, the project does not include the `.pro.user` file. After opening the project, go to the **Projects** tab in Creator and set up your kit(s). You will need to add two custom process steps to the compilation to make sure the lexer and parser are regenerated should you make any changes to Flex or Bison source files:

 * **Custom process step**
   * Command: `bison`
   * Argument: `parser.y`
   * Working directory: `%{sourceDir}`
 * **Custom process step**
   * Command: `flex`
   * Argument: `scanner.l`
   * Working directory: `%{sourceDir}`

Compiling with GCC 5.4.0 on Xubuntu 16.04 _should_ return with only one warning (a `-Wsign-compare` in `scanner.cpp`, line 1102). Your mileage may vary.

## Input files

Once compiled, the executable needs an input file to parse. The simple -- and rather nonsensical -- "Sample input file" (`.sif`) format consists of:

 * An opening line containing `HELLO`
 * Any number of specification lines of the format `max number align alignment`, where `number` must be an integer and `alignment` is either `left`, `right` or `center`.
 * A closing line containing `GOODBYE`
 
For each specification line, the program creates two widgets in the "Parse results" frame: a spinbox from 0 to the number given after `max`, and a label with the text "Sample text" and the alignment specified (left, right or center).

## About

This description is not meant to be an exhaustive tutorial on Bison/Flex or Qt, but a general description of the approach I used for integrating them.

### Making an `#include`able lexer/parser

Bison and Flex need to be told to generate header files, so that they can be `#include`ed in other parts of the project. This can be accomplished by command line parameters to the `flex` and `bison` calls, or (my preferred method) using directives inside the source files. Here's an overview of the options I used in this project:

- **Bison ([`parser.y`](parser.y))**
  - Output file: [`parser.cpp`](parser.cpp) (use `%output "parser.cpp"`)
  - Header file: [`parser.h`](parser.h) (use `%defines "parser.h"`)
- **Flex ([`scanner.l`](scanner.l))**
  - The first section (between `%{` and `%}`) must contain an `#include` to the header file generated by Bison (in this case `parser.h`)
  - Output file: [`scanner.cpp`](scanner.cpp) (use `%option outfile="scanner.cpp"`)
  - Header file: [`scanner.h`](scanner.h) (use `%option header-file="scanner.h"`)

Note that specifying the output file names is not required, it was only used for consistency (i.e. matching base names, as well as `.cpp` extensions as opposed to the default `.c`). As mentioned in [Setup](#setup), Bison and Flex must be run (in that order) to generate the lexer/parser:

```
bison parser.y
flex scanner.l
```

The lexer/parser can be used by including the header files at the desired point in the project.

### The Flex source

As mentioned [above](#making-an-includeable-lexerparser), the top section needs to `#include` the Bison-generated header. The only other include in this project is `<cstdlib>`, as char-to-integer conversion is done by `atoi()`. The `yylex()` and `yyerror()` declarations are basically boilerplate. The `noyywrap` and `nounput` options are used to suppress compiler warnings and to avoid having to declare a "dummy" `yywrap()` function (or macro).

### The Bison source

Bison can make use of any Qt class, although this is somewhat obscured by having all declarations in [`common.h`](common.h) ( e.g. `elements_t` is a `typedef` for a `QVector` of `ParseElement` objects). This seems to be restricted, however, to actual C++ blocks, i.e. the top and bottom sections as well as any (brace-enclosed) actions within rules. The `%union` directive, for example, would not accept `Qt::AlignmentFlag`, which is why that type is passed between rules by `static_cast`ing to/from `int`.

In case of an error, `yyerror()` throws an exception and stops parsing (the exception propagates up and is caught by the `try` block surrounding the call to `yyparse()` in [`testparser.cpp`](testparser.cpp)). This was done to keep this demo simple, however, there are possibilities for more sophisticated error handling and reporting. For example, while you canâ€™t use `emit` within the Bison source (since it won't be processed by [moc][moc]), you can create a `QObject` with proxy methods emitting signals, and call those from the actions. By using the [`qRegisterMetatype<>()`][qregistermetatype] method, any\* object can be sent through the signal/slot mechanism.

\*From the [docs][qregistermetatype]: "Any class or struct that has a public default constructor, a public copy constructor and a public destructor can be registered."

[creator]: http://doc.qt.io/qtcreator/index.html
[kits]: http://doc.qt.io/qtcreator/creator-targets.html
[moc]: http://doc.qt.io/qt-5/moc.html
[qregistermetatype]: http://doc.qt.io/qt-5/qmetatype.html#qRegisterMetaType
